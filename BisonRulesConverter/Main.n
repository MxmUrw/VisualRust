using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Console;
using System.Linq;

using BisonRulesParser;

using Nitra.Declarations;
using Nitra.ProjectSystem;

module Program
{
    Main() : void
    {
        def lang = NitraBison.Instance;
        def file = FsFile("parser-lalr.y", lang);
        def context = DependentPropertyEvalContext();
        def propsEvalHost = ProjectEvalPropertiesHost([file]);
        
        propsEvalHost.EvalProperties(context, "Collect variables", 0); 
        propsEvalHost.EvalProperties(context, "Compute variables", 1);
        
        WriteLine(GenerateNitraGrammar(file.Ast :> GrammarFile));
        _ = ReadLine();
    }
    
    GenerateNitraGrammar(grammarFile : GrammarFile) : string
    {                
        mutable result = "";
        
        foreach (rule in grammarFile.Rules)
        {
            def components = rule.RuleComponents.OfType.[RuleComponent.NotEmpty]();
            
            if (rule.HasDirectLeftRecursion)
            {
                def (heads, tails) = components.NToList().Partition(c => 
                        match (c.Symbols.First())
                        {
                            | c is Symbol.Reference => c.Reference.Id != rule.Name.Id
                            | _ => true
                        });
                        
                if (heads.Any())
                {
                    result += GenerateCompoundRule(
                        $"$(rule.Name) = ($(rule.Name)_heads $(rule.Name)_tails*)" + if (rule.IsOptional) "?" else "",
                        [GenerateRule(rule.Name + "_heads", heads.Map(x => x.Symbols), "", "\t"),
                         GenerateRule(rule.Name + "_tails", tails.Map(x => x.Symbols.Skip(1)), "", "\t")]);                     
                }
                else
                {
                    result += GenerateRule(rule.Name.Text, tails.Map(x => x.Symbols.Skip(1)), "*");
                }
            }
            else
            {
                result += GenerateRule(rule.Name.Text, components.Map(x => x.Symbols), if (rule.IsOptional) "?" else "");
            }
            
            result += "\n\n";
        }
        
        result
    }
            
    GenerateRule(name : string, components : IEnumerable[IEnumerable[Symbol]], optional = "", ident = "") : string
    {
        def GenerateSymbols(symbols : IEnumerable[Symbol])
        {            
            def GenerateSymbol(symbol : Symbol)
            {
                match (symbol)
                {
                    | x is Symbol.Reference        => x.Reference.Text
                    | x is Symbol.CharacterLiteral => $<#"$(x.Value)"#>
                }
            }
        
            $<#..$(symbols; " "; GenerateSymbol)#>
        }
        
        if (components.Count() == 1)
        {
            if (!optional.IsEmpty())
            {
                if (components.First().Count() > 1)
                    ident + $"syntax $name = (" + GenerateSymbols(components.First()) + ")" + optional + ";"
                 else
                    ident + $"syntax $name = " + GenerateSymbols(components.First()) + optional + ";"
            }
            else
                ident + $"syntax $name = " + GenerateSymbols(components.First()) + ";"
        }
        else
        {
            mutable body = ident;
            
            if (!optional.IsEmpty())
            {
                body += $"syntax $name = $(name)_internal$optional\n$ident{" + GenerateRule(name + "_internal", components, "", ident + "\t");
            }
            else
            {
                body += $"syntax $name\n$ident{";                
                foreach (component in components with index)
                    body += $"\n$ident\t| $name$index = " + GenerateSymbols(component);
            }
                
            body + $"\n$ident}"
        }
    }
        
    GenerateCompoundRule(rule : string, subrules : IEnumerable[string], ident = "") : string
    {
        mutable result = ident + $"syntax $rule\n$ident{\n";
            
        foreach (subrule in subrules)
            result += ident + subrule + "\n";
                
        result + $"$ident}"
    }    
}
