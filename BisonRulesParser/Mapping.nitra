using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using BisonRulesParser.AstUtils;

using BisonRulesParser.Grammar;

using Nitra.Declarations;

namespace BisonRulesParser
{
	abstract ast Symbol
	{
		in  ContainingTable : TableScope;
		| Reference 
		{
			Reference : Nitra.Declarations.Reference;
			Reference.Scope =  ContainingTable;
		}
		| CharacterLiteral
		{

		}
	}

	abstract ast RuleComponent
	{
		in  ContainingTable : TableScope;

		| Empty
		{
			
		}
		| NotEmpty
		{
			Symbols : Symbol*;
			Symbols.ContainingTable =  ContainingTable;
		}
	}

	ast GrammarFile
	{
		out ContainingTable : TableScope = TableScope("Global", null);
		
		Rules : Rule*;

		Rules.ContainingTable = ContainingTable;
	}
	
	declaration Rule
	{
		RuleComponents : RuleComponent*;

		out isOptional : bool = RuleComponents.ContainsType(typeof(RuleComponent.Empty));
		
		RuleComponents.ContainingTable =  ContainingTable;
	}

	map syntax Main.GrammarFile -> GrammarFile
	{
		RulesSection -> Rules;
	}

	map syntax Main.Symbol -> Symbol
	{
		| Reference -> Reference 
		{
			Reference -> Reference;
		}
		| CharacterLiteral -> CharacterLiteral 
		{
			
		}
	}

	map syntax Main.RulesSection -> Rule*
	{
		Rules
	}

	map syntax Main.RuleComponent -> RuleComponent
	{
		| NotEmpty -> NotEmpty
		{
			Symbols -> Symbols;
		}
		| Empty -> Empty 
		{
		}
	}

	map syntax Main.Rule -> Rule
	{
		Name -> Name;
		RuleComponents.Item1 -> RuleComponents;
	}

}
