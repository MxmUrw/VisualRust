namespace Nitrust.Rust.Grammar
{
  syntax module Items
  {
	using Nitra.Core;

	using Identifiers;
	using Attributes;
	using Types;

	syntax Visibility = "pub" sm;
	
	syntax AttrsAndVis = OuterAttr* Visibility?;

	syntax ModItem = AttrsAndVis Item;

	syntax Item
	{
		| StmtItem
		//| ItemMacro
	}

	//TODO:
	syntax StmtItem
	{
		//| ItemStatic
		//| ItemConst
		//| ItemType
		| BlockItem
		| ViewItem
	}

	//TODO:
	syntax BlockItem
	{
		//| ItemFn
		//| ItemUnsafeFn
		| ItemMod
		//| ItemForeignMod
		//| ItemStruct
		//| ItemEnum
		//| ItemTrait
		//| ItemImpl

	}

	syntax ItemMod
	{
		| ItemMod1 = "mod" Name ';'
		| ItemMod2 = "mod" Name '{' InnerAttr* ModItem* '}'
	}

	//TODO:
	syntax ViewItem
	{
		| UseItem
		//| extern_fn_item
		| "extern" "crate" Reference ("as" Name)?';'
	}

	syntax UseItem = "use" ViewPath ';';

	syntax ViewPath
	{
		| PathNoTypesAllowed
		| ViewPathList = (PathNoTypesAllowed? "::")? '{' (IdentsOrSelf ','?)?'}'
		| ViewPathGlob = PathNoTypesAllowed  "::" '*' 
		| ViewPathListEmpty = '{' '}'
		| ViewPathSimple = PathNoTypesAllowed "as" Name
		
		syntax IdentOrSelf
		{
			| Reference
			| "self"
		}

		syntax IdentsOrSelf = (IdentOrSelf ("as" Name)?; ',')+;
	}

	// A path with no type parameters; e.g. `foo::bar::Baz`
	//
	// These show up in 'use' view-items, because these are processed
	// without respect to types.
	syntax PathNoTypesAllowed = PathNoTypesAllowedHead ("::" Reference)*
	{
		syntax PathNoTypesAllowedHead
		{
			| PathNoTypesAllowedHead1 = Reference
			| PathNoTypesAllowedHead2 = "::" Reference
			| PathNoTypesAllowedHead3 = "self"
			| PathNoTypesAllowedHead4 = "::" "self" 
		}
	}

	//TODO:
	syntax PathGenericArgsWithoutColons
	{ 
		| PathGenericArgsWithoutColons1 = Reference
		| PathGenericArgsWithoutColons2 = Reference GenericArgs
		//| %prec IDENT
		//  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node("components", 2, $1, $3); }
		//| %prec IDENT
		//  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }
		//| %prec IDENT
		//  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }
		//| %prec IDENT
		//  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }
	}

	//TODO:
	syntax GenericArgs
	{
		| GenericArgs1 = '<' GenericValues '>'
		| GenericArgs2 = '<' GenericValues ">>"
		| GenericArgs3 = '<' GenericValues ">="
		| GenericArgs4 = '<' GenericValues ">>="
		// If generic_args starts with "<<", the first arg must be a
		// TyQualifiedPath because that's the only type that can start with a
		// '<'. This rule parses that as the first ty_sum and then continues
		// with the rest of generic_values.
		//| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }
		//| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }
		//| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }
		//| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }
	}

	syntax GenericValues = Lifetimes? TySumsAndOrBindings?;

	syntax TySumsAndOrBindings
	{
		| TySumsAndOrBindings1 = (TySum; ',')+ ','?
		| TySumsAndOrBindings2 = (TySum; ',')+ ',' (Binding; ',')+
		| TySumsAndOrBindings3 = (Binding; ',')+ ','?
	}
	
  }
}