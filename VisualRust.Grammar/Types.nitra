namespace Nitrust.Rust.Grammar
{
  syntax module Types
  {
	using Nitra.Core;

	using Identifiers;
	using Items;

	//TODO:
	syntax Ty
	{
		| TyPrim
		//| TyClosure
		//| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      
		//| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident 
		| TyTup = '(' (TySum; ',')+ ','? ')'                                                        
		| TyNil = '(' ')'
	}

	//TODO:
	syntax TyPrim
	{
		| PathGenericArgsWithoutColons
		| "self"? "::" PathGenericArgsWithoutColons
		| TyBox = "box" Ty
		| TyPtr = '*' MutOrConst? Ty
		| TyRptr1 = '&' Ty
		| TyRptr2 ='&' "mut" Ty
		| TyRptr3 = "&&" Ty
		| TyRptr4 = "&&" "mut" Ty
		| TyRptr5 = '&' Lifetime "mut"? Ty
		| TyRptr6 = "&&" Lifetime "mut"? Ty
		| TyVec = '[' Ty ']'
		//| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node("TyFixedLengthVec", 2, $2, $5); }
		//| '[' ty ';' expr ']'                                       { $$ = mk_node("TyFixedLengthVec", 2, $2, $4); }
		//| TYPEOF '(' expr ')'                                       { $$ = mk_node("TyTypeof", 1, $3); }
		| TyInfer = '_'
		//| ty_bare_fn
		//| ty_proc
		//| for_in_type
	}

	regex MutOrConst = "mut" | "const";

	syntax Lifetime
	{	
		| NamedLifetime = "'" Name
		| StaticLifetime = "'" "static"
	}
	
	syntax TySum = Ty ('+' TyParamBounds)?;

	syntax TyParamBounds = Boundseq?;

	syntax Boundseq = (Polybound; '+')+;
	
	syntax Polybound 
	{
		| Polybound1 = "for" '<' MaybeLifetimes '>' Bound
		| Polybound2 = '?'? Bound
	}

	syntax MaybeLifetimes = (Lifetimes; ',')*;

	syntax Lifetimes = (LifetimeAndBounds; ',')+;

	syntax LifetimeAndBounds
	{
		| LifetimeAndBounds1 = Lifetime Ltbounds?
		| LifetimeAndBounds2 = "static"
	}

	syntax Ltbounds = ':' (Lifetime; '+')+;

	//TODO:
	syntax Bound 
	{
		| Lifetime
		//| TraitRef
	}

	syntax Binding = Name '=' Ty;
  }
}