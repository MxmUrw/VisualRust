namespace Nitrust.Rust.Grammar
{
  syntax module Types
  {
	using Nitra.Core;

	using Identifiers;
	using Items;

	//TODO:
	syntax Ty
	{
		| TyPrim
		//| TyClosure
		| TyQualifiedPath1 = '<' TySum ("as" TraitRef)? '>' "::" Reference
		| TyQualifiedPath2 = "<<" TySum ("as" TraitRef)? '>' "::" Reference ("as" TraitRef)? '>' "::" Reference
		| TyTup = '(' (TySum; ',')+ ','? ')'
		| TyNil = '(' ')'
	}

	//TODO:
	syntax TyPrim
	{
		| PathGenericArgsWithoutColons
		| "self"? "::" PathGenericArgsWithoutColons
		| TyBox = "box" Ty
		| TyPtr = '*' MutOrConst? Ty
		| TyRptr1 = '&' Ty
		| TyRptr2 ='&' "mut" Ty
		| TyRptr3 = "&&" Ty
		| TyRptr4 = "&&" "mut" Ty
		| TyRptr5 = '&' Lifetime "mut"? Ty
		| TyRptr6 = "&&" Lifetime "mut"? Ty
		| TyVec = '[' Ty ']'
		//| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node("TyFixedLengthVec", 2, $2, $5); }
		//| '[' ty ';' expr ']'                                       { $$ = mk_node("TyFixedLengthVec", 2, $2, $4); }
		//| TYPEOF '(' expr ')'                                       { $$ = mk_node("TyTypeof", 1, $3); }
		| TyInfer = '_'
		//| ty_bare_fn
		//| ty_proc
		//| for_in_type
	}

	syntax WhereClause = "where" (WherePredicate; ',')+ ','?;
	
	syntax WherePredicate
	{
		| WherePredicate1 = ForLifetimes? Lifetime ':' (Bound; '+')+;
		| WherePredicate2 = ForLifetimes? Ty ':' TyParamBounds;
	} 
	
	syntax ForLifetimes = "for" '<' Lifetimes '>';

	regex MutOrConst = "mut" | "const";

	syntax TyQualifiedPathAndGenericValues
	{
		| TyQualifiedPathAndGenericValues1 = TyQualifiedPath (',' (Binding; ',')+)?
		| TyQualifiedPathAndGenericValues2 = TyQualifiedPath ',' (TySum; ',')+ (',' (Binding; ',')+)?
	}

	syntax TyQualifiedPath = TySum "as" TraitRef '>' "::" Reference ('+' TyParamBounds)?;

	syntax Lifetime
	{	
		| NamedLifetime = "'" Name
		| StaticLifetime = "'" "static"
	}
	
	syntax TySum = Ty ('+' TyParamBounds)?;

	syntax TyParamBounds = Boundseq?;

	syntax Boundseq = (Polybound; '+')+;
	
	syntax Polybound 
	{
		| Polybound1 = "for" '<' MaybeLifetimes '>' Bound
		| Polybound2 = '?'? Bound
	}

	syntax MaybeLifetimes = (Lifetimes; ',')*;

	syntax Lifetimes = (LifetimeAndBounds; ',')+;

	syntax LifetimeAndBounds
	{
		| LifetimeAndBounds1 = Lifetime Ltbounds?
		| LifetimeAndBounds2 = "static"
	}

	syntax Ltbounds = ':' (Lifetime; '+')+;

	syntax Bound 
	{
		| Lifetime
		| TraitRef
	}

	syntax Binding = Name '=' Ty;

	syntax TraitRef = "::"? PathGenericArgsWithoutColons;
  }
}