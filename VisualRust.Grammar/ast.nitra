using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using Nitra.Declarations;
using Nitra;

namespace VisualRust.Grammar
{
	ast Crate
	{
		out ContainingTable : TableScope = TableScope("Global", null);

		Attributes : Attribute*;

		ModItems : ModItem*;

		Attributes.ContainingTable = ContainingTable;
	}

	map syntax Rules.crate -> Crate
	{
		Inner_attrs -> Attributes;

		Mod_items -> ModItems;
	}

	abstract ast Attribute
	{
		in  ContainingTable : TableScope;

		| Empty
		| NotEmpty
		{
			MetaItem : MetaItemAst;
			MetaItem.ContainingTable = ContainingTable;
		}
	}

	map syntax Rules.inner_attr -> Attribute
	{
		| inner_attr0 -> Attribute.NotEmpty 
		{
			Meta_item -> MetaItem;
		}
		| inner_attr1 -> Attribute.Empty {}
	}

	map syntax Rules.outer_attr -> Attribute
	{
		| outer_attr0 -> Attribute.NotEmpty 
		{
			Meta_item -> MetaItem;
		}
		| outer_attr1 -> Attribute.Empty {}
	}

	abstract ast MetaItemAst
	{
		in  ContainingTable : TableScope;
		| MetaWord { Name : Name; }
		| MetaNameValue	{ Name : Name; }  
		| MetaList { MetaItems : MetaItemAst*; }
	}

	map syntax Rules.meta_item -> MetaItemAst
	{
		| meta_item0 -> MetaWord 
			{ 
				Name -> Name;
			}
		| meta_item1 -> MetaNameValue 
			{
				Name -> Name;
			}
		| meta_item2 -> MetaList { Meta_items.Item1 -> MetaItems; }
	}

	ast AttrsAndVisibility
	{
		Attributes : Attribute*;

		IsVisible : bool;
	}

	map syntax Rules.attrs_and_vis -> AttrsAndVisibility
	{ 
		Outer_attrs -> Attributes;
		
		IsVisible = ParsedValue(PUBOpt.Span, PUBOpt.HasValue);
	}

	abstract ast PathReference
	{
		| Self
		| Super
		| Reference { Value : Nitra.Declarations.Reference; }
	}

	ast UsePath
	{
		IsGlobal : bool;
		
		Path : PathReference*;
		
		Tails : RefOrSelfPathReference*;
	}

	abstract ast ModItem
	{
		| UseItem
		{
			UsePath : UsePath;
		}
		| Other
	}

	map syntax Rules.mod_item -> ModItem
	{
		Item
	}

	map syntax Rules.item -> ModItem
	{
		| item0 -> this.Stmt_item
		| item1 -> Other {}


	}

	map syntax Rules.stmt_item -> ModItem
	{
		| stmt_item0  -> Other {}
		| stmt_item1  -> Other {}
		| stmt_item2  -> Other {}
		| stmt_item3  -> Other {}
		| stmt_item4  -> this.View_item
	}

	map syntax Rules.view_item -> ModItem
	{
		| view_item0  -> ModItem.UseItem
			{
				Use_item.View_path -> UsePath;
			}
		| view_item1  -> Other {}
		| view_item2  -> Other {}
	}

	map syntax Rules.view_path -> UsePath
	{
		| view_path0 -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path_no_types_allowed -> Path;
			Tails = RefOrSelfPathReference.AstList(this);
		}
		| view_path1 -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path_no_types_allowed -> Path;
			Tails = RefOrSelfPathReference.AstList(this);
		}
		
		| view_path2 -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path =	PathReference.AstList(this);
			Tails = RefOrSelfPathReference.AstList(this);
		}
		| view_path3  -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path_no_types_allowed -> Path;
			Refs_or_self -> Tails;
		}
		| view_path4  -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path = PathReference.AstList(this);
			Refs_or_self -> Tails;
		}
		| view_path5  -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path_no_types_allowed -> Path;
			Tails = RefOrSelfPathReference.AstList(this);
		}
		| view_path6  -> UsePath
		{
			IsGlobal = ParsedValue(MOD_SEPOpt.Span, MOD_SEPOpt.HasValue);
			Path_no_types_allowed -> Path;
			Tails = RefOrSelfPathReference.AstList(this);
		}

	}
	
	map syntax Rules.path_no_types_allowed_tail -> PathReference
	{
		| tail0 -> Reference 
		{
			Reference -> Value;
		}
		| tail1 -> Super {}
	}
	
	map syntax Rules.path_no_types_allowed -> PathReference* = AstUtils.Convert_path_no_types_allowed(this);

	map syntax Rules.path_no_types_allowed_head -> PathReference
	{
		| head0 -> Reference
		{
			Reference -> Value;
		}
		| head1 -> Self {}
		| head2 -> Super {}
	}

	map syntax Rules.ref_or_self -> PathReference
	{
		| ident_or_self0 -> Reference
		{
			Reference -> Value;
		}

		| ident_or_self1 -> Self {}
	}


	abstract ast RefOrSelfPathReference
    {
		| Simple { PathReference : PathReference; }
		| Aliased { PathReference : PathReference; Alias : Name;}
    } 


	map syntax Rules.refs_or_self_part -> RefOrSelfPathReference
	{
	  match (NameOpt)
	  {
		| Some((_, name)) -> RefOrSelfPathReference.Aliased { Ref_or_self -> PathReference; name -> Alias; }
		| None            -> RefOrSelfPathReference.Simple  { Ref_or_self -> PathReference; }
	  }
	}

	map syntax Rules.refs_or_self -> RefOrSelfPathReference*
	{
		Refs_or_self_parts.Item1
	}

}
