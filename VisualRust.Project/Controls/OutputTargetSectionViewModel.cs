using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Data;
using VisualRust.Cargo;

namespace VisualRust.Project.Controls
{
    public class OutputTargetSectionViewModel: ViewModelBase, IPropertyPageContext
    {
        readonly ManifestFile manifest;
        // We keep all the targets in a one big collection because CompositeCollection doesn't support grouping
        readonly int libraries = 1;
        int binaries;
        int tests;
        int benchmarks;
        int examples;

        public string ManifestPath { get { return manifest.Path; } }

        ObservableCollection<IOutputTargetViewModel> targets;
        public ObservableCollection<IOutputTargetViewModel> Targets
        {
            get { return targets; }
            set
            {
                Set(ref targets, value);
            }
        }

        IOutputTargetViewModel selectedTarget;
        public IOutputTargetViewModel SelectedTarget
        {
            get { return selectedTarget; }
            set
            {
                Set(ref selectedTarget, value);
            }
        }

        public event EventHandler DirtyChanged;

        private bool isDirty;
        public bool IsDirty
        {
            get { return isDirty; }
            set
            {
                isDirty = value;
                var temp = DirtyChanged;
                if(temp != null)
                    temp(null, null);
            }
        }

        readonly Func<OutputTargetSectionViewModel, OutputTargetType?> addSelector;

        public OutputTargetSectionViewModel(ManifestFile m, Func<OutputTargetSectionViewModel, OutputTargetType?> addSelector)
        {
            this.addSelector = addSelector;
            this.manifest = m;
            targets = new ObservableCollection<IOutputTargetViewModel>();
            var lookup = manifest.Manifest.OutputTargets.ToLookup(t => t.Type);
            OutputTarget rawLibraryTarget = lookup[OutputTargetType.Library].FirstOrDefault();
            targets.Add(CreateLibraryTarget(rawLibraryTarget));
            binaries =  LoadTargets(lookup[OutputTargetType.Binary], () => new BinaryAutoOutputTargetViewModel(manifest.Manifest));
            tests =  LoadTargets(lookup[OutputTargetType.Test], () => new TestAutoOutputTargetViewModel(manifest.Manifest));
            benchmarks =  LoadTargets(lookup[OutputTargetType.Benchmark], () => new BenchmarkAutoOutputTargetViewModel(manifest.Manifest));
            examples =  LoadTargets(lookup[OutputTargetType.Example], () => new ExampleAutoOutputTargetViewModel(manifest.Manifest));
            targets.Add(new CommandOutputTargetViewModel(this.Add));
            SelectedTarget = Targets.Where(f => !(f is CommandOutputTargetViewModel))
                                    .OrderBy(f => f.Type)
                                    .ThenBy(f => f.Name)
                                    .First();
        }

        public void Add()
        {
            OutputTargetType? type = addSelector(this);
            if(!type.HasValue)
                return;
            var vm = new OutputTargetViewModel(this.manifest.Manifest, this, new OutputTarget(type.Value));
            IOutputTargetViewModel autoTarget = this.Targets.FirstOrDefault(t => t.IsAutoGenerated && t.Type == type.Value);
            if(autoTarget != null)
                this.Targets.Remove(autoTarget);
            this.Targets.Add(vm);
            SelectedTarget = vm;
            IsDirty = true;
        }

        public void Remove(OutputTargetViewModel target)
        {
            Targets.Remove(target);
            IsDirty = true;
        }

        public void Apply()
        {
            OutputTargetChanges changes = PendingChanges();
            manifest.Apply(changes);
            IsDirty = false;
        }

        IOutputTargetViewModel CreateLibraryTarget(OutputTarget rawLibraryTarget)
        {
            if(rawLibraryTarget == null)
                return new LibraryAutoOutputTargetViewModel(manifest.Manifest);
            return new OutputTargetViewModel(manifest.Manifest, this, rawLibraryTarget);
        }

        int LoadTargets(IEnumerable<OutputTarget> rawTargets, Func<IOutputTargetViewModel> ctor)
        {
            List<OutputTargetViewModel> vms = rawTargets.Select(t => new OutputTargetViewModel(manifest.Manifest, this, t)).ToList();
            if(vms.Count == 0)
            {
                Targets.Add(ctor());
                return 1;
            }
            else
            {
                foreach(OutputTargetViewModel vm in vms)
                    Targets.Add(vm);
                return vms.Count;
            }
        }

        public OutputTargetChanges PendingChanges()
        {
            return new OutputTargetChanges(
                this.manifest.Manifest,
                this.Targets.OfType<OutputTargetViewModel>());
        }
    }
}
